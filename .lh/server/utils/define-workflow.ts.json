{
    "sourceFile": "server/utils/define-workflow.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1732213948439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1732213974426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n             meta: job.meta,\n           };\n \n           await this.beforeJobRun?.(jobEvent);\n-          runTask(\"db:migrate\", { ...event });\n+          runTask(\"db:migrate\", { payload: event.payload, context: event.context });\n           await this.afterJobRun?.(jobEvent);\n         }\n \n         await this.afterRun?.(workflowEvent);\n"
                },
                {
                    "date": 1732214006896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n           };\n \n           await this.beforeJobRun?.(jobEvent);\n           runTask(\"db:migrate\", {\n-            payload: event.payload,\n+            payload: event.payload as TaskPayload,\n             context: event.context,\n           });\n           await this.afterJobRun?.(jobEvent);\n         }\n"
                }
            ],
            "date": 1732213948439,
            "name": "Commit-0",
            "content": "import { ZodSchema } from \"zod\";\n\n// Helper function to wrap workflow middleware methods\nfunction wrapWorkflowMiddleware<\n    RT = unknown,\n    Payload = Record<string, any>,\n    Context = Record<string, any>,\n    Hook extends keyof WorkflowMiddleware<RT, Payload, Context> = keyof WorkflowMiddleware<\n        RT,\n        Payload,\n        Context\n    >\n>(\n    middlewares: WorkflowMiddleware<RT, Payload, Context>[],\n    methodName: Hook,\n    fallback?: WorkflowMiddleware<RT, Payload, Context>[Hook]\n): (event: WorkflowEvent<Payload, Context>, ...args: any[]) => Promise<void> {\n    return async (event, ...args) => {\n        for (const middleware of middlewares) {\n            const method = middleware[methodName];\n            if (method) {\n                // @ts-ignore\n                await method(event, ...args);\n            }\n        }\n        if (fallback) {\n            // @ts-ignore\n            await fallback(event, ...args);\n        }\n    };\n}\n\n// Function to define a workflow with middleware and lifecycle hooks\nexport function defineWorkflow<\n    RT = unknown,\n    Payload = Record<string, any>,\n    Context = Record<string, any>\n>(def: Workflow<RT, Payload, Context>): Workflow<RT, Payload, Context> {\n    if (typeof def.run !== \"function\") {\n        throw new TypeError(\"Workflow must implement a `run` method!\");\n    }\n\n    const middlewares: WorkflowMiddleware<RT, Payload, Context>[] = def.middlewares || [];\n\n    const beforeRun = wrapWorkflowMiddleware(middlewares, \"beforeRun\", def.beforeRun);\n    const afterRun = wrapWorkflowMiddleware(middlewares, \"afterRun\", def.afterRun);\n    const onError = wrapWorkflowMiddleware(middlewares, \"onError\", def.onError);\n    const onComplete = wrapWorkflowMiddleware(middlewares, \"onComplete\", def.onComplete);\n    const beforeJobRun = wrapWorkflowMiddleware(middlewares, \"beforeJobRun\", def.beforeJobRun);\n    const afterJobRun = wrapWorkflowMiddleware(middlewares, \"afterJobRun\", def.afterJobRun);\n\n    return {\n        ...def,\n        async beforeRun(event: WorkflowEvent<Payload, Context>) {\n            await beforeRun(event);\n        },\n        async afterRun(event: WorkflowEvent<Payload, Context>) {\n            await afterRun(event);\n        },\n        async onError(event: WorkflowEvent<Payload, Context>, error: Error) {\n            await onError(event, error);\n        },\n        async onComplete(event: WorkflowEvent<Payload, Context>) {\n            await onComplete(event);\n        },\n        async beforeJobRun(event: JobEvent<Payload, Context>) {\n            await beforeJobRun(event);\n        },\n        async afterJobRun(event: JobEvent<Payload, Context>) {\n            await afterJobRun(event);\n        },\n        async run(event: WorkflowEvent<Payload, Context>) {\n            const workflowEvent: WorkflowEvent<Payload, Context> = { ...event, meta: def.meta };\n\n            // Validate payload using schema, if provided\n            if (def.meta.schema) {\n                const schema = def.meta.schema as ZodSchema<Payload>;\n                workflowEvent.payload = schema.parse(event.payload);\n            }\n\n            try {\n                await this.beforeRun?.(workflowEvent);\n\n                // Execute each job in the workflow\n                for (const jobName of def.meta.jobs) {\n                    const job = getJobByName(jobName); // Implement job retrieval logic\n                    if (!job) {\n                        throw new Error(`Job not found: ${jobName}`);\n                    }\n\n                    const jobEvent: JobEvent<Payload, Context> = {\n                        ...workflowEvent,\n                        meta: job.meta,\n                    };\n\n                    await this.beforeJobRun?.(jobEvent);\n                    runTask(\"db:migrate\", { ...event });\n                    await this.afterJobRun?.(jobEvent);\n                }\n\n                await this.afterRun?.(workflowEvent);\n            } catch (error) {\n                await this.onError?.(workflowEvent, error as Error);\n                return { result: \"Failure\", event: workflowEvent, error };\n            } finally {\n                await this.onComplete?.(workflowEvent);\n            }\n\n            return { result: \"Success\", event: workflowEvent };\n        },\n    };\n}\n\n// Placeholder function to retrieve a job by name\nfunction getJobByName(name: string): Job | undefined {\n    // Implement logic to retrieve the job instance based on the name\n    return undefined;\n}"
        }
    ]
}