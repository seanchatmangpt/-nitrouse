{
    "sourceFile": "server/utils/define-job.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1732132875330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1732132895729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,5 @@\n import { ZodSchema } from \"zod\";\n-import { createError } from \"h3\";\n import type { TaskEvent, TaskPayload, TaskResult } from \"nitropack/types\";\n \n export interface JobMeta {\n   name: string;\n"
                },
                {
                    "date": 1732133641474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,64 +1,89 @@\n import { ZodSchema } from \"zod\";\n-import type { TaskEvent, TaskPayload, TaskResult } from \"nitropack/types\";\n+import type { TaskEvent } from \"nitropack/types\";\n \n+/**\n+ * Metadata for a job.\n+ */\n export interface JobMeta {\n   name: string;\n   description?: string;\n   schema?: ZodSchema; // Optional payload validation schema\n }\n \n+/**\n+ * Extended TaskEvent to include job metadata.\n+ */\n+export interface JobEvent extends TaskEvent {\n+  meta: JobMeta; // Attach metadata to the event\n+}\n+\n+/**\n+ * A job definition with lifecycle hooks and execution logic.\n+ */\n export interface Job<RT = unknown> {\n   meta: JobMeta;\n-  beforeRun?: (event: TaskEvent) => Promise<void> | void; // Before job logic\n-  afterRun?: (event: TaskEvent, result: RT) => Promise<void> | void; // After job logic\n-  onError?: (event: TaskEvent, error: Error) => Promise<void> | void; // Error handling\n-  onComplete?: (event: TaskEvent) => Promise<void> | void; // Cleanup logic\n-  run: (event: TaskEvent) => Promise<TaskResult<RT>>; // Main job execution\n+  beforeRun?: (event: JobEvent) => Promise<void> | void; // Logic to run before the main job\n+  afterRun?: (event: JobEvent, result: RT) => Promise<void> | void; // Logic to run after the main job\n+  onError?: (event: JobEvent, error: Error) => Promise<void> | void; // Error handling logic\n+  onComplete?: (event: JobEvent) => Promise<void> | void; // Cleanup logic to run regardless of success/failure\n+  run: (event: JobEvent) => Promise<RT>; // Main job execution logic\n }\n \n /**\n  * Define a job with hooks, schema validation, and execution logic.\n+ *\n+ * @param def - The job definition\n+ * @returns The validated job object\n  */\n export function defineJob<RT = unknown>(def: Job<RT>): Job<RT> {\n+  // Ensure the job defines a `run` function\n   if (typeof def.run !== \"function\") {\n     throw new TypeError(\"Job must implement a `run` method!\");\n   }\n \n   return {\n     ...def,\n     async run(event) {\n+      let result: RT;\n+\n+      // Extend TaskEvent to create JobEvent\n+      const jobEvent: JobEvent = {\n+        ...event,\n+        meta: def.meta,\n+      };\n+\n       try {\n         // Execute `beforeRun` hook\n         if (def.beforeRun) {\n-          await def.beforeRun(event);\n+          await def.beforeRun(jobEvent);\n         }\n \n         // Validate payload against schema if provided\n         if (def.meta.schema) {\n-          const schema = def.meta.schema as ZodSchema<TaskPayload>;\n+          const schema = def.meta.schema as ZodSchema;\n           schema.parse(event.payload);\n         }\n \n         // Execute main job logic\n-        const result = await def.run(event);\n+        result = await def.run(jobEvent);\n \n         // Execute `afterRun` hook\n         if (def.afterRun) {\n-          await def.afterRun(event, result.result);\n+          await def.afterRun(jobEvent, result);\n         }\n \n         return result;\n       } catch (error) {\n         // Handle error in `onError` hook\n         if (def.onError) {\n-          await def.onError(event, error as Error);\n+          await def.onError(jobEvent, error as Error);\n         }\n         throw error;\n       } finally {\n         // Execute `onComplete` hook\n         if (def.onComplete) {\n-          await def.onComplete(event);\n+          await def.onComplete(jobEvent);\n         }\n       }\n     },\n   };\n"
                },
                {
                    "date": 1732135067587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import { createHooks } from \"hookable\";\n+\n import { ZodSchema } from \"zod\";\n import type { TaskEvent } from \"nitropack/types\";\n \n /**\n@@ -35,56 +37,39 @@\n  * @param def - The job definition\n  * @returns The validated job object\n  */\n export function defineJob<RT = unknown>(def: Job<RT>): Job<RT> {\n-  // Ensure the job defines a `run` function\n   if (typeof def.run !== \"function\") {\n     throw new TypeError(\"Job must implement a `run` method!\");\n   }\n \n+  // Create a Hookable instance for the job\n+  const hooks = createHooks();\n+\n   return {\n     ...def,\n     async run(event) {\n-      let result: RT;\n+      const jobEvent: JobEvent = { ...event, meta: def.meta };\n \n-      // Extend TaskEvent to create JobEvent\n-      const jobEvent: JobEvent = {\n-        ...event,\n-        meta: def.meta,\n-      };\n-\n       try {\n-        // Execute `beforeRun` hook\n-        if (def.beforeRun) {\n-          await def.beforeRun(jobEvent);\n-        }\n+        // Call `beforeRun` hooks\n+        await hooks.callHook(\"beforeRun\", jobEvent);\n \n-        // Validate payload against schema if provided\n-        if (def.meta.schema) {\n-          const schema = def.meta.schema as ZodSchema;\n-          schema.parse(event.payload);\n-        }\n-\n         // Execute main job logic\n-        result = await def.run(jobEvent);\n+        const result = await def.run(jobEvent);\n \n-        // Execute `afterRun` hook\n-        if (def.afterRun) {\n-          await def.afterRun(jobEvent, result);\n-        }\n+        // Call `afterRun` hooks\n+        await hooks.callHook(\"afterRun\", jobEvent, result);\n \n         return result;\n       } catch (error) {\n-        // Handle error in `onError` hook\n-        if (def.onError) {\n-          await def.onError(jobEvent, error as Error);\n-        }\n+        // Call `onError` hooks\n+        await hooks.callHook(\"onError\", jobEvent, error);\n         throw error;\n       } finally {\n-        // Execute `onComplete` hook\n-        if (def.onComplete) {\n-          await def.onComplete(jobEvent);\n-        }\n+        // Call `onComplete` hooks\n+        await hooks.callHook(\"onComplete\", jobEvent);\n       }\n     },\n+    hooks, // Expose hooks for dynamic registration\n   };\n }\n"
                },
                {
                    "date": 1732135107508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,9 @@\n   afterRun?: (event: JobEvent, result: RT) => Promise<void> | void; // Logic to run after the main job\n   onError?: (event: JobEvent, error: Error) => Promise<void> | void; // Error handling logic\n   onComplete?: (event: JobEvent) => Promise<void> | void; // Cleanup logic to run regardless of success/failure\n   run: (event: JobEvent) => Promise<RT>; // Main job execution logic\n+  hooks: Hookable<Record<string, any>, string>;\n }\n \n /**\n  * Define a job with hooks, schema validation, and execution logic.\n"
                },
                {
                    "date": 1732135437763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,39 +1,10 @@\n-import { createHooks } from \"hookable\";\n+import { createHooks, Hookable } from \"hookable\";\n+import types from \"#types\";\n \n import { ZodSchema } from \"zod\";\n-import type { TaskEvent } from \"nitropack/types\";\n \n /**\n- * Metadata for a job.\n- */\n-export interface JobMeta {\n-  name: string;\n-  description?: string;\n-  schema?: ZodSchema; // Optional payload validation schema\n-}\n-\n-/**\n- * Extended TaskEvent to include job metadata.\n- */\n-export interface JobEvent extends TaskEvent {\n-  meta: JobMeta; // Attach metadata to the event\n-}\n-\n-/**\n- * A job definition with lifecycle hooks and execution logic.\n- */\n-export interface Job<RT = unknown> {\n-  meta: JobMeta;\n-  beforeRun?: (event: JobEvent) => Promise<void> | void; // Logic to run before the main job\n-  afterRun?: (event: JobEvent, result: RT) => Promise<void> | void; // Logic to run after the main job\n-  onError?: (event: JobEvent, error: Error) => Promise<void> | void; // Error handling logic\n-  onComplete?: (event: JobEvent) => Promise<void> | void; // Cleanup logic to run regardless of success/failure\n-  run: (event: JobEvent) => Promise<RT>; // Main job execution logic\n-  hooks: Hookable<Record<string, any>, string>;\n-}\n-\n-/**\n  * Define a job with hooks, schema validation, and execution logic.\n  *\n  * @param def - The job definition\n  * @returns The validated job object\n"
                },
                {
                    "date": 1732135450409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import { createHooks, Hookable } from \"hookable\";\n-import types from \"#types\";\n+import { Job, JobEvent, JobMeta } from \"types\";\n \n import { ZodSchema } from \"zod\";\n \n /**\n"
                },
                {
                    "date": 1732141861067,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,47 +1,74 @@\n-import { createHooks, Hookable } from \"hookable\";\n-import { Job, JobEvent, JobMeta } from \"types\";\n-\n-import { ZodSchema } from \"zod\";\n-\n-/**\n- * Define a job with hooks, schema validation, and execution logic.\n- *\n- * @param def - The job definition\n- * @returns The validated job object\n- */\n-export function defineJob<RT = unknown>(def: Job<RT>): Job<RT> {\n+export function defineJob<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>\n+>(def: Job<RT, Payload, Context>): Job<RT, Payload, Context> {\n   if (typeof def.run !== \"function\") {\n     throw new TypeError(\"Job must implement a `run` method!\");\n   }\n \n-  // Create a Hookable instance for the job\n-  const hooks = createHooks();\n+  // Default to an empty middleware array if none provided\n+  const middlewares = def.middlewares || [];\n \n-  return {\n+  // Wrap lifecycle hooks and the `run` function with middleware\n+  const wrapMiddleware = (\n+    methodName: keyof JobMiddleware<RT, Payload, Context>\n+  ) => {\n+    return async (...args: any[]) => {\n+      for (const middleware of middlewares) {\n+        const method = middleware[methodName];\n+        if (typeof method === \"function\") {\n+          await method(...args);\n+        }\n+      }\n+      const method = def[methodName];\n+      if (typeof method === \"function\") {\n+        await method(...args);\n+      }\n+    };\n+  };\n+\n+  const job: Job<RT, Payload, Context> = {\n     ...def,\n+    async beforeRun(event) {\n+      await wrapMiddleware(\"beforeRun\")(event);\n+    },\n+    async afterRun(event, result) {\n+      await wrapMiddleware(\"afterRun\")(event, result);\n+    },\n+    async onError(event, error) {\n+      await wrapMiddleware(\"onError\")(event, error);\n+    },\n+    async onComplete(event) {\n+      await wrapMiddleware(\"onComplete\")(event);\n+    },\n     async run(event) {\n-      const jobEvent: JobEvent = { ...event, meta: def.meta };\n+      const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n \n-      try {\n-        // Call `beforeRun` hooks\n-        await hooks.callHook(\"beforeRun\", jobEvent);\n+      // Validate the payload against the schema, if defined\n+      if (def.meta.schema) {\n+        const schema = def.meta.schema as ZodSchema<Payload>;\n+        jobEvent.payload = schema.parse(event.payload);\n+      }\n \n-        // Execute main job logic\n-        const result = await def.run(jobEvent);\n+      // Run middleware wrapping the main execution\n+      let result: RT;\n+      for (const middleware of middlewares) {\n+        if (middleware.run) {\n+          result = await middleware.run(jobEvent);\n+          return result; // If middleware overrides `run`, stop execution\n+        }\n+      }\n \n-        // Call `afterRun` hooks\n-        await hooks.callHook(\"afterRun\", jobEvent, result);\n+      // Execute the main job logic\n+      result = await def.run(jobEvent);\n \n-        return result;\n-      } catch (error) {\n-        // Call `onError` hooks\n-        await hooks.callHook(\"onError\", jobEvent, error);\n-        throw error;\n-      } finally {\n-        // Call `onComplete` hooks\n-        await hooks.callHook(\"onComplete\", jobEvent);\n-      }\n+      // Call afterRun hook\n+      await job.afterRun(jobEvent, result);\n+\n+      return result;\n     },\n-    hooks, // Expose hooks for dynamic registration\n   };\n+\n+  return job;\n }\n"
                },
                {
                    "date": 1732143789901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,74 +1,33 @@\n-export function defineJob<\n+export function wrapWithMiddleware<\n   RT = unknown,\n   Payload = Record<string, any>,\n-  Context = Record<string, any>\n->(def: Job<RT, Payload, Context>): Job<RT, Payload, Context> {\n-  if (typeof def.run !== \"function\") {\n-    throw new TypeError(\"Job must implement a `run` method!\");\n-  }\n-\n-  // Default to an empty middleware array if none provided\n-  const middlewares = def.middlewares || [];\n-\n-  // Wrap lifecycle hooks and the `run` function with middleware\n-  const wrapMiddleware = (\n-    methodName: keyof JobMiddleware<RT, Payload, Context>\n-  ) => {\n-    return async (...args: any[]) => {\n-      for (const middleware of middlewares) {\n-        const method = middleware[methodName];\n-        if (typeof method === \"function\") {\n-          await method(...args);\n-        }\n+  Context = Record<string, any>,\n+  Hook extends keyof JobMiddleware<RT, Payload, Context> = keyof JobMiddleware<\n+    RT,\n+    Payload,\n+    Context\n+  >\n+>(\n+  middlewares: JobMiddleware<RT, Payload, Context>[],\n+  methodName: Hook,\n+  fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n+): (\n+  event: JobEvent<Payload, Context>,\n+  ...args: Hook extends \"afterRun\"\n+    ? [result: RT]\n+    : Hook extends \"onError\"\n+    ? [error: Error]\n+    : []\n+) => Promise<void> {\n+  return async (event, ...args) => {\n+    for (const middleware of middlewares) {\n+      const method = middleware[methodName];\n+      if (method) {\n+        await method(event, ...args);\n       }\n-      const method = def[methodName];\n-      if (typeof method === \"function\") {\n-        await method(...args);\n-      }\n-    };\n+    }\n+    if (fallback) {\n+      await fallback(event, ...args);\n+    }\n   };\n-\n-  const job: Job<RT, Payload, Context> = {\n-    ...def,\n-    async beforeRun(event) {\n-      await wrapMiddleware(\"beforeRun\")(event);\n-    },\n-    async afterRun(event, result) {\n-      await wrapMiddleware(\"afterRun\")(event, result);\n-    },\n-    async onError(event, error) {\n-      await wrapMiddleware(\"onError\")(event, error);\n-    },\n-    async onComplete(event) {\n-      await wrapMiddleware(\"onComplete\")(event);\n-    },\n-    async run(event) {\n-      const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n-\n-      // Validate the payload against the schema, if defined\n-      if (def.meta.schema) {\n-        const schema = def.meta.schema as ZodSchema<Payload>;\n-        jobEvent.payload = schema.parse(event.payload);\n-      }\n-\n-      // Run middleware wrapping the main execution\n-      let result: RT;\n-      for (const middleware of middlewares) {\n-        if (middleware.run) {\n-          result = await middleware.run(jobEvent);\n-          return result; // If middleware overrides `run`, stop execution\n-        }\n-      }\n-\n-      // Execute the main job logic\n-      result = await def.run(jobEvent);\n-\n-      // Call afterRun hook\n-      await job.afterRun(jobEvent, result);\n-\n-      return result;\n-    },\n-  };\n-\n-  return job;\n }\n"
                },
                {
                    "date": 1732143849208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,18 +16,82 @@\n   ...args: Hook extends \"afterRun\"\n     ? [result: RT]\n     : Hook extends \"onError\"\n     ? [error: Error]\n-    : []\n+    : any[]\n ) => Promise<void> {\n   return async (event, ...args) => {\n     for (const middleware of middlewares) {\n       const method = middleware[methodName];\n       if (method) {\n+        // @ts-ignore\n         await method(event, ...args);\n       }\n     }\n     if (fallback) {\n+      // @ts-ignore\n       await fallback(event, ...args);\n     }\n   };\n }\n+\n+export function defineJob<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>\n+>(def: Job<RT, Payload, Context>): Job<RT, Payload, Context> {\n+  if (typeof def.run !== \"function\") {\n+    throw new TypeError(\"Job must implement a `run` method!\");\n+  }\n+\n+  const middlewares: JobMiddleware<RT, Payload, Context>[] =\n+    def.middlewares || [];\n+\n+  const beforeRun = wrapWithMiddleware(middlewares, \"beforeRun\", def.beforeRun);\n+  const afterRun = wrapWithMiddleware(middlewares, \"afterRun\", def.afterRun);\n+  const onError = wrapWithMiddleware(middlewares, \"onError\", def.onError);\n+  const onComplete = wrapWithMiddleware(\n+    middlewares,\n+    \"onComplete\",\n+    def.onComplete\n+  );\n+\n+  return {\n+    ...def,\n+    async beforeRun(event: JobEvent<Payload, Context>) {\n+      await beforeRun(event);\n+    },\n+    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n+      await afterRun(event, result);\n+    },\n+    async onError(event: JobEvent<Payload, Context>, error: Error) {\n+      await onError(event, error);\n+    },\n+    async onComplete(event: JobEvent<Payload, Context>) {\n+      await onComplete(event);\n+    },\n+    async run(event: JobEvent<Payload, Context>) {\n+      const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n+\n+      // Validate payload using schema, if provided\n+      if (def.meta.schema) {\n+        const schema = def.meta.schema as ZodSchema<Payload>;\n+        jobEvent.payload = schema.parse(event.payload);\n+      }\n+\n+      await this.beforeRun(jobEvent);\n+\n+      let result: RT;\n+      try {\n+        result = await def.run(jobEvent);\n+        await this.afterRun(jobEvent, result);\n+      } catch (error) {\n+        await this.onError(jobEvent, error as Error);\n+        throw error;\n+      } finally {\n+        await this.onComplete(jobEvent);\n+      }\n+\n+      return result;\n+    },\n+  };\n+}\n"
                },
                {
                    "date": 1732143897459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n         const schema = def.meta.schema as ZodSchema<Payload>;\n         jobEvent.payload = schema.parse(event.payload);\n       }\n \n-      await this.beforeRun(jobEvent);\n+      if (this.beforeRun) await this.beforeRun(jobEvent);\n \n       let result: RT;\n       try {\n         result = await def.run(jobEvent);\n"
                },
                {
                    "date": 1732143980294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,19 +77,19 @@\n         const schema = def.meta.schema as ZodSchema<Payload>;\n         jobEvent.payload = schema.parse(event.payload);\n       }\n \n-      if (this.beforeRun) await this.beforeRun(jobEvent);\n+      this.beforeRun && (await this.beforeRun(jobEvent));\n \n       let result: RT;\n       try {\n         result = await def.run(jobEvent);\n-        await this.afterRun(jobEvent, result);\n+        this.afterRun && (await this.afterRun(jobEvent, result));\n       } catch (error) {\n-        await this.onError(jobEvent, error as Error);\n+        this.onError && (await this.onError(jobEvent, error as Error));\n         throw error;\n       } finally {\n-        await this.onComplete(jobEvent);\n+        this.onComplete && (await this.onComplete(jobEvent));\n       }\n \n       return result;\n     },\n"
                },
                {
                    "date": 1732143992424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import { ZodSchema } from \"zod\";\n+\n export function wrapWithMiddleware<\n   RT = unknown,\n   Payload = Record<string, any>,\n   Context = Record<string, any>,\n"
                },
                {
                    "date": 1732144523581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,21 +79,26 @@\n         const schema = def.meta.schema as ZodSchema<Payload>;\n         jobEvent.payload = schema.parse(event.payload);\n       }\n \n-      this.beforeRun && (await this.beforeRun(jobEvent));\n+      await this.beforeRun?.(jobEvent);\n \n-      let result: RT;\n+      let result: RT | undefined;\n       try {\n         result = await def.run(jobEvent);\n-        this.afterRun && (await this.afterRun(jobEvent, result));\n+\n+        // Let middleware modify the result after execution\n+        await this.afterRun?.(jobEvent, result);\n+\n+        // Wrap the result as \"Success\"\n+        return { result: \"Success\", ...result };\n       } catch (error) {\n-        this.onError && (await this.onError(jobEvent, error as Error));\n-        throw error;\n+        await this.onError?.(jobEvent, error as Error);\n+\n+        // Return a wrapped \"Failure\" result\n+        return { result: \"Failure\", error };\n       } finally {\n-        this.onComplete && (await this.onComplete(jobEvent));\n+        await this.onComplete?.(jobEvent);\n       }\n-\n-      return result;\n     },\n   };\n }\n"
                },
                {
                    "date": 1732144726033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-import { ZodSchema } from \"zod\";\n-\n export function wrapWithMiddleware<\n   RT = unknown,\n   Payload = Record<string, any>,\n   Context = Record<string, any>,\n@@ -61,9 +59,12 @@\n     ...def,\n     async beforeRun(event: JobEvent<Payload, Context>) {\n       await beforeRun(event);\n     },\n-    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n+    async afterRun(\n+      event: JobEvent<Payload, Context>,\n+      result: MutableResult<RT>\n+    ) {\n       await afterRun(event, result);\n     },\n     async onError(event: JobEvent<Payload, Context>, error: Error) {\n       await onError(event, error);\n@@ -81,17 +82,17 @@\n       }\n \n       await this.beforeRun?.(jobEvent);\n \n-      let result: RT | undefined;\n+      const result: MutableResult<RT> = { value: undefined as unknown as RT };\n       try {\n-        result = await def.run(jobEvent);\n+        result.value = await def.run(jobEvent);\n \n-        // Let middleware modify the result after execution\n+        // Allow middleware to modify the result\n         await this.afterRun?.(jobEvent, result);\n \n         // Wrap the result as \"Success\"\n-        return { result: \"Success\", ...result };\n+        return { result: \"Success\", ...result.value };\n       } catch (error) {\n         await this.onError?.(jobEvent, error as Error);\n \n         // Return a wrapped \"Failure\" result\n"
                },
                {
                    "date": 1732144787764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import { ZodSchema } from \"zod\";\n+\n export function wrapWithMiddleware<\n   RT = unknown,\n   Payload = Record<string, any>,\n   Context = Record<string, any>,\n@@ -59,12 +61,9 @@\n     ...def,\n     async beforeRun(event: JobEvent<Payload, Context>) {\n       await beforeRun(event);\n     },\n-    async afterRun(\n-      event: JobEvent<Payload, Context>,\n-      result: MutableResult<RT>\n-    ) {\n+    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n       await afterRun(event, result);\n     },\n     async onError(event: JobEvent<Payload, Context>, error: Error) {\n       await onError(event, error);\n@@ -82,17 +81,17 @@\n       }\n \n       await this.beforeRun?.(jobEvent);\n \n-      const result: MutableResult<RT> = { value: undefined as unknown as RT };\n+      let result: RT | undefined;\n       try {\n-        result.value = await def.run(jobEvent);\n+        result = await def.run(jobEvent);\n \n-        // Allow middleware to modify the result\n+        // Let middleware modify the result after execution\n         await this.afterRun?.(jobEvent, result);\n \n         // Wrap the result as \"Success\"\n-        return { result: \"Success\", ...result.value };\n+        return { result: \"Success\", ...result };\n       } catch (error) {\n         await this.onError?.(jobEvent, error as Error);\n \n         // Return a wrapped \"Failure\" result\n"
                },
                {
                    "date": 1732144986682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,9 @@\n     },\n     async onComplete(event: JobEvent<Payload, Context>) {\n       await onComplete(event);\n     },\n+    // @ts-ignore\n     async run(event: JobEvent<Payload, Context>) {\n       const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n \n       // Validate payload using schema, if provided\n@@ -81,9 +82,9 @@\n       }\n \n       await this.beforeRun?.(jobEvent);\n \n-      let result: RT | undefined;\n+      let result: RT = {} as RT;\n       try {\n         result = await def.run(jobEvent);\n \n         // Let middleware modify the result after execution\n"
                },
                {
                    "date": 1732145381107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,99 @@\n+import { ZodSchema } from \"zod\";\n+\n+export function wrapWithMiddleware<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>,\n+  Hook extends keyof JobMiddleware<RT, Payload, Context> = keyof JobMiddleware<\n+    RT,\n+    Payload,\n+    Context\n+  >\n+>(\n+  middlewares: JobMiddleware<RT, Payload, Context>[],\n+  methodName: Hook,\n+  fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n+): (\n+  event: JobEvent<Payload, Context>,\n+  ...args: Hook extends \"afterRun\"\n+    ? [result: RT]\n+    : Hook extends \"onError\"\n+    ? [error: Error]\n+    : any[]\n+) => Promise<void> {\n+  return async (event, ...args) => {\n+    for (const middleware of middlewares) {\n+      const method = middleware[methodName];\n+      if (method) {\n+        await method(event, ...args);\n+      }\n+    }\n+    if (fallback) {\n+      await fallback(event, ...args);\n+    }\n+  };\n+}\n+\n+export function defineJob<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>\n+>(def: Job<RT, Payload, Context>): Job<RT, Payload, Context> {\n+  if (typeof def.run !== \"function\") {\n+    throw new TypeError(\"Job must implement a `run` method!\");\n+  }\n+\n+  const middlewares: JobMiddleware<RT, Payload, Context>[] =\n+    def.middlewares || [];\n+\n+  const beforeRun = wrapWithMiddleware(middlewares, \"beforeRun\", def.beforeRun);\n+  const afterRun = wrapWithMiddleware(middlewares, \"afterRun\", def.afterRun);\n+  const onError = wrapWithMiddleware(middlewares, \"onError\", def.onError);\n+  const onComplete = wrapWithMiddleware(\n+    middlewares,\n+    \"onComplete\",\n+    def.onComplete\n+  );\n+\n+  return {\n+    ...def,\n+    async beforeRun(event: JobEvent<Payload, Context>) {\n+      await beforeRun(event);\n+    },\n+    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n+      await afterRun(event, result);\n+    },\n+    async onError(event: JobEvent<Payload, Context>, error: Error) {\n+      await onError(event, error);\n+    },\n+    async onComplete(event: JobEvent<Payload, Context>) {\n+      await onComplete(event);\n+    },\n+    async run(event: JobEvent<Payload, Context>) {\n+      const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n+\n+      // Validate payload using schema, if provided\n+      if (def.meta.schema) {\n+        const schema = def.meta.schema as ZodSchema<Payload>;\n+        jobEvent.payload = schema.parse(event.payload);\n+      }\n+\n+      await this.beforeRun?.(jobEvent);\n+\n+      try {\n+        const result = await def.run(jobEvent);\n+\n+        // Allow middleware to modify the event\n+        await this.afterRun?.(jobEvent, result);\n+\n+        return { result: \"Success\", event: jobEvent };\n+      } catch (error) {\n+        await this.onError?.(jobEvent, error as Error);\n+\n+        return { result: \"Failure\", event: jobEvent, error };\n+      } finally {\n+        await this.onComplete?.(jobEvent);\n+      }\n+    },\n+  };\n+}\n"
                },
                {
                    "date": 1732145403994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,12 +24,14 @@\n   return async (event, ...args) => {\n     for (const middleware of middlewares) {\n       const method = middleware[methodName];\n       if (method) {\n+        // @ts-ignore\n         await method(event, ...args);\n       }\n     }\n     if (fallback) {\n+      // @ts-ignore\n       await fallback(event, ...args);\n     }\n   };\n }\n@@ -68,8 +70,9 @@\n     },\n     async onComplete(event: JobEvent<Payload, Context>) {\n       await onComplete(event);\n     },\n+    // @ts-ignore\n     async run(event: JobEvent<Payload, Context>) {\n       const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n \n       // Validate payload using schema, if provided\n@@ -96,109 +99,4 @@\n       }\n     },\n   };\n }\n-import { ZodSchema } from \"zod\";\n-\n-export function wrapWithMiddleware<\n-  RT = unknown,\n-  Payload = Record<string, any>,\n-  Context = Record<string, any>,\n-  Hook extends keyof JobMiddleware<RT, Payload, Context> = keyof JobMiddleware<\n-    RT,\n-    Payload,\n-    Context\n-  >\n->(\n-  middlewares: JobMiddleware<RT, Payload, Context>[],\n-  methodName: Hook,\n-  fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n-): (\n-  event: JobEvent<Payload, Context>,\n-  ...args: Hook extends \"afterRun\"\n-    ? [result: RT]\n-    : Hook extends \"onError\"\n-    ? [error: Error]\n-    : any[]\n-) => Promise<void> {\n-  return async (event, ...args) => {\n-    for (const middleware of middlewares) {\n-      const method = middleware[methodName];\n-      if (method) {\n-        // @ts-ignore\n-        await method(event, ...args);\n-      }\n-    }\n-    if (fallback) {\n-      // @ts-ignore\n-      await fallback(event, ...args);\n-    }\n-  };\n-}\n-\n-export function defineJob<\n-  RT = unknown,\n-  Payload = Record<string, any>,\n-  Context = Record<string, any>\n->(def: Job<RT, Payload, Context>): Job<RT, Payload, Context> {\n-  if (typeof def.run !== \"function\") {\n-    throw new TypeError(\"Job must implement a `run` method!\");\n-  }\n-\n-  const middlewares: JobMiddleware<RT, Payload, Context>[] =\n-    def.middlewares || [];\n-\n-  const beforeRun = wrapWithMiddleware(middlewares, \"beforeRun\", def.beforeRun);\n-  const afterRun = wrapWithMiddleware(middlewares, \"afterRun\", def.afterRun);\n-  const onError = wrapWithMiddleware(middlewares, \"onError\", def.onError);\n-  const onComplete = wrapWithMiddleware(\n-    middlewares,\n-    \"onComplete\",\n-    def.onComplete\n-  );\n-\n-  return {\n-    ...def,\n-    async beforeRun(event: JobEvent<Payload, Context>) {\n-      await beforeRun(event);\n-    },\n-    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n-      await afterRun(event, result);\n-    },\n-    async onError(event: JobEvent<Payload, Context>, error: Error) {\n-      await onError(event, error);\n-    },\n-    async onComplete(event: JobEvent<Payload, Context>) {\n-      await onComplete(event);\n-    },\n-    // @ts-ignore\n-    async run(event: JobEvent<Payload, Context>) {\n-      const jobEvent: JobEvent<Payload, Context> = { ...event, meta: def.meta };\n-\n-      // Validate payload using schema, if provided\n-      if (def.meta.schema) {\n-        const schema = def.meta.schema as ZodSchema<Payload>;\n-        jobEvent.payload = schema.parse(event.payload);\n-      }\n-\n-      await this.beforeRun?.(jobEvent);\n-\n-      let result: RT = {} as RT;\n-      try {\n-        result = await def.run(jobEvent);\n-\n-        // Let middleware modify the result after execution\n-        await this.afterRun?.(jobEvent, result);\n-\n-        // Wrap the result as \"Success\"\n-        return { result: \"Success\", ...result };\n-      } catch (error) {\n-        await this.onError?.(jobEvent, error as Error);\n-\n-        // Return a wrapped \"Failure\" result\n-        return { result: \"Failure\", error };\n-      } finally {\n-        await this.onComplete?.(jobEvent);\n-      }\n-    },\n-  };\n-}\n"
                },
                {
                    "date": 1732145545049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,10 +61,10 @@\n     ...def,\n     async beforeRun(event: JobEvent<Payload, Context>) {\n       await beforeRun(event);\n     },\n-    async afterRun(event: JobEvent<Payload, Context>, result: RT) {\n-      await afterRun(event, result);\n+    async afterRun(event: JobEvent<Payload, Context>) {\n+      await afterRun(event);\n     },\n     async onError(event: JobEvent<Payload, Context>, error: Error) {\n       await onError(event, error);\n     },\n@@ -86,17 +86,16 @@\n       try {\n         const result = await def.run(jobEvent);\n \n         // Allow middleware to modify the event\n-        await this.afterRun?.(jobEvent, result);\n-\n-        return { result: \"Success\", event: jobEvent };\n+        await this.afterRun?.(jobEvent);\n       } catch (error) {\n         await this.onError?.(jobEvent, error as Error);\n \n         return { result: \"Failure\", event: jobEvent, error };\n       } finally {\n         await this.onComplete?.(jobEvent);\n       }\n+      return { result: \"Success\", event: jobEvent };\n     },\n   };\n }\n"
                },
                {
                    "date": 1732145942708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,8 @@\n   fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n ): (\n   event: JobEvent<Payload, Context>,\n   ...args: Hook extends \"afterRun\"\n-    ? [result: RT]\n     : Hook extends \"onError\"\n     ? [error: Error]\n     : any[]\n ) => Promise<void> {\n"
                },
                {
                    "date": 1732145958440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,10 +14,10 @@\n   methodName: Hook,\n   fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n ): (\n   event: JobEvent<Payload, Context>,\n-  ...args: Hook extends \"afterRun\"\n-    : Hook extends \"onError\"\n+  ...args: Hook extends \"afterRun\" ?\n+    Hook extends \"onError\" ?\n     ? [error: Error]\n     : any[]\n ) => Promise<void> {\n   return async (event, ...args) => {\n"
                },
                {
                    "date": 1732146335884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,21 +12,15 @@\n >(\n   middlewares: JobMiddleware<RT, Payload, Context>[],\n   methodName: Hook,\n   fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n-): (\n-  event: JobEvent<Payload, Context>,\n-  ...args: Hook extends \"afterRun\" ?\n-    Hook extends \"onError\" ?\n-    ? [error: Error]\n-    : any[]\n-) => Promise<void> {\n+): (event: JobEvent<Payload, Context>, ...args: any[]) => Promise<void> {\n   return async (event, ...args) => {\n     for (const middleware of middlewares) {\n       const method = middleware[methodName];\n       if (method) {\n         // @ts-ignore\n-        await method(event, ...args);\n+        await method(event, ...args); // No more type-specific `result` or `error` handling\n       }\n     }\n     if (fallback) {\n       // @ts-ignore\n"
                },
                {
                    "date": 1732146381902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,11 +73,11 @@\n         const schema = def.meta.schema as ZodSchema<Payload>;\n         jobEvent.payload = schema.parse(event.payload);\n       }\n \n-      await this.beforeRun?.(jobEvent);\n+      try {\n+        await this.beforeRun?.(jobEvent);\n \n-      try {\n         const result = await def.run(jobEvent);\n \n         // Allow middleware to modify the event\n         await this.afterRun?.(jobEvent);\n"
                }
            ],
            "date": 1732132875330,
            "name": "Commit-0",
            "content": "import { ZodSchema } from \"zod\";\nimport { createError } from \"h3\";\nimport type { TaskEvent, TaskPayload, TaskResult } from \"nitropack/types\";\n\nexport interface JobMeta {\n  name: string;\n  description?: string;\n  schema?: ZodSchema; // Optional payload validation schema\n}\n\nexport interface Job<RT = unknown> {\n  meta: JobMeta;\n  beforeRun?: (event: TaskEvent) => Promise<void> | void; // Before job logic\n  afterRun?: (event: TaskEvent, result: RT) => Promise<void> | void; // After job logic\n  onError?: (event: TaskEvent, error: Error) => Promise<void> | void; // Error handling\n  onComplete?: (event: TaskEvent) => Promise<void> | void; // Cleanup logic\n  run: (event: TaskEvent) => Promise<TaskResult<RT>>; // Main job execution\n}\n\n/**\n * Define a job with hooks, schema validation, and execution logic.\n */\nexport function defineJob<RT = unknown>(def: Job<RT>): Job<RT> {\n  if (typeof def.run !== \"function\") {\n    throw new TypeError(\"Job must implement a `run` method!\");\n  }\n\n  return {\n    ...def,\n    async run(event) {\n      try {\n        // Execute `beforeRun` hook\n        if (def.beforeRun) {\n          await def.beforeRun(event);\n        }\n\n        // Validate payload against schema if provided\n        if (def.meta.schema) {\n          const schema = def.meta.schema as ZodSchema<TaskPayload>;\n          schema.parse(event.payload);\n        }\n\n        // Execute main job logic\n        const result = await def.run(event);\n\n        // Execute `afterRun` hook\n        if (def.afterRun) {\n          await def.afterRun(event, result.result);\n        }\n\n        return result;\n      } catch (error) {\n        // Handle error in `onError` hook\n        if (def.onError) {\n          await def.onError(event, error as Error);\n        }\n        throw error;\n      } finally {\n        // Execute `onComplete` hook\n        if (def.onComplete) {\n          await def.onComplete(event);\n        }\n      }\n    },\n  };\n}\n"
        }
    ]
}