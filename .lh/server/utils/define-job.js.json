{
    "sourceFile": "server/utils/define-job.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1732142053689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1732142636264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     },\n     async onComplete(event) {\n       await wrapMiddleware(\"onComplete\")(event);\n     },\n-    async run(event) {\n+    run(event) {\n       const jobEvent = { ...event, meta: def.meta };\n \n       // Validate payload with schema if provided\n       if (def.meta && def.meta.schema) {\n"
                },
                {
                    "date": 1732143048851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+export function defineJob(def) {\n+  if (typeof def.run !== \"function\") {\n+    throw new TypeError(\"Job must implement a `run` method!\");\n+  }\n+\n+  return {\n+    ...def,\n+    async run(event) {\n+      const jobEvent = { ...event, meta: def.meta };\n+\n+      // Validate payload with schema if provided\n+      if (def.meta && def.meta.schema) {\n+        jobEvent.payload = def.meta.schema.parse(event.payload);\n+      }\n+\n+      // Execute lifecycle hooks and main job logic\n+      if (def.beforeRun) {\n+        await def.beforeRun(jobEvent);\n+      }\n+\n+      let result;\n+      try {\n+        result = await def.run(jobEvent);\n+        if (def.afterRun) {\n+          await def.afterRun(jobEvent, result);\n+        }\n+      } catch (error) {\n+        if (def.onError) {\n+          await def.onError(jobEvent, error);\n+        }\n+        throw error; // Re-throw to let callers handle it\n+      } finally {\n+        if (def.onComplete) {\n+          await def.onComplete(jobEvent);\n+        }\n+      }\n+\n+      return result;\n+    },\n+  };\n+}\n"
                },
                {
                    "date": 1732143371339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,103 +2,58 @@\n   if (typeof def.run !== \"function\") {\n     throw new TypeError(\"Job must implement a `run` method!\");\n   }\n \n-  return {\n-    ...def,\n-    async run(event) {\n-      const jobEvent = { ...event, meta: def.meta };\n-\n-      // Validate payload with schema if provided\n-      if (def.meta && def.meta.schema) {\n-        jobEvent.payload = def.meta.schema.parse(event.payload);\n-      }\n-\n-      // Execute lifecycle hooks and main job logic\n-      if (def.beforeRun) {\n-        await def.beforeRun(jobEvent);\n-      }\n-\n-      let result;\n-      try {\n-        result = await def.run(jobEvent);\n-        if (def.afterRun) {\n-          await def.afterRun(jobEvent, result);\n-        }\n-      } catch (error) {\n-        if (def.onError) {\n-          await def.onError(jobEvent, error);\n-        }\n-        throw error; // Re-throw to let callers handle it\n-      } finally {\n-        if (def.onComplete) {\n-          await def.onComplete(jobEvent);\n-        }\n-      }\n-\n-      return result;\n-    },\n-  };\n-}\n-export function defineJob(def) {\n-  if (typeof def.run !== \"function\") {\n-    throw new TypeError(\"Job must implement a `run` method!\");\n-  }\n-\n   const middlewares = def.middlewares || [];\n \n-  // Helper to wrap lifecycle hooks and run logic\n-  const wrapMiddleware = (methodName) => {\n-    return async (...args) => {\n+  const wrapWithMiddleware = (methodName) => {\n+    return async (event, ...args) => {\n       for (const middleware of middlewares) {\n-        if (typeof middleware[methodName] === \"function\") {\n-          await middleware[methodName](...args);\n+        if (middleware[methodName]) {\n+          await middleware[methodName](event, ...args);\n         }\n       }\n-      if (typeof def[methodName] === \"function\") {\n-        await def[methodName](...args);\n+      if (def[methodName]) {\n+        await def[methodName](event, ...args);\n       }\n     };\n   };\n \n   return {\n     ...def,\n     async beforeRun(event) {\n-      await wrapMiddleware(\"beforeRun\")(event);\n+      await wrapWithMiddleware(\"beforeRun\")(event);\n     },\n     async afterRun(event, result) {\n-      await wrapMiddleware(\"afterRun\")(event, result);\n+      await wrapWithMiddleware(\"afterRun\")(event, result);\n     },\n     async onError(event, error) {\n-      await wrapMiddleware(\"onError\")(event, error);\n+      await wrapWithMiddleware(\"onError\")(event, error);\n     },\n     async onComplete(event) {\n-      await wrapMiddleware(\"onComplete\")(event);\n+      await wrapWithMiddleware(\"onComplete\")(event);\n     },\n-    run(event) {\n+    async run(event) {\n       const jobEvent = { ...event, meta: def.meta };\n \n       // Validate payload with schema if provided\n       if (def.meta && def.meta.schema) {\n         jobEvent.payload = def.meta.schema.parse(event.payload);\n       }\n \n+      await this.beforeRun(jobEvent);\n+\n       let result;\n-\n-      // Run middleware that wraps the main logic\n-      for (const middleware of middlewares) {\n-        if (middleware.run) {\n-          result = await middleware.run(jobEvent);\n-          return result; // Stop execution if middleware overrides `run`\n-        }\n+      try {\n+        result = await def.run(jobEvent);\n+        await this.afterRun(jobEvent, result);\n+      } catch (error) {\n+        await this.onError(jobEvent, error);\n+        throw error;\n+      } finally {\n+        await this.onComplete(jobEvent);\n       }\n \n-      // Run the main job logic\n-      result = await def.run(jobEvent);\n-\n-      // Call afterRun hooks\n-      await this.afterRun(jobEvent, result);\n-\n       return result;\n     },\n   };\n }\n"
                },
                {
                    "date": 1732143631722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,59 +1,49 @@\n-export function defineJob(def) {\n-  if (typeof def.run !== \"function\") {\n-    throw new TypeError(\"Job must implement a `run` method!\");\n-  }\n-\n-  const middlewares = def.middlewares || [];\n-\n-  const wrapWithMiddleware = (methodName) => {\n-    return async (event, ...args) => {\n-      for (const middleware of middlewares) {\n-        if (middleware[methodName]) {\n-          await middleware[methodName](event, ...args);\n-        }\n+export function wrapWithMiddleware<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>,\n+  Hook extends keyof JobMiddleware<RT, Payload, Context> = keyof JobMiddleware<RT, Payload, Context>\n+>(\n+  middlewares: JobMiddleware<RT, Payload, Context>[],\n+  methodName: Hook,\n+  fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n+): (\n+  event: JobEvent<Payload, Context>,\n+  ...args: Hook extends \"afterRun\" ? [result: RT] : Hook extends \"onError\" ? [error: Error] : []\n+) => Promise<void> {\n+  return async (event, ...args) => {\n+    for (const middleware of middlewares) {\n+      if (middleware[methodName]) {\n+        await middleware[methodName]!(event, ...args);\n       }\n-      if (def[methodName]) {\n-        await def[methodName](event, ...args);\n-      }\n-    };\n+    }\n+    if (fallback) {\n+      await fallback(event, ...args);\n+    }\n   };\n+}\n \n-  return {\n-    ...def,\n-    async beforeRun(event) {\n-      await wrapWithMiddleware(\"beforeRun\")(event);\n-    },\n-    async afterRun(event, result) {\n-      await wrapWithMiddleware(\"afterRun\")(event, result);\n-    },\n-    async onError(event, error) {\n-      await wrapWithMiddleware(\"onError\")(event, error);\n-    },\n-    async onComplete(event) {\n-      await wrapWithMiddleware(\"onComplete\")(event);\n-    },\n-    async run(event) {\n-      const jobEvent = { ...event, meta: def.meta };\n-\n-      // Validate payload with schema if provided\n-      if (def.meta && def.meta.schema) {\n-        jobEvent.payload = def.meta.schema.parse(event.payload);\n+export function wrapWithMiddleware<\n+  RT = unknown,\n+  Payload = Record<string, any>,\n+  Context = Record<string, any>,\n+  Hook extends keyof JobMiddleware<RT, Payload, Context> = keyof JobMiddleware<RT, Payload, Context>\n+>(\n+  middlewares: JobMiddleware<RT, Payload, Context>[],\n+  methodName: Hook,\n+  fallback?: JobMiddleware<RT, Payload, Context>[Hook]\n+): (\n+  event: JobEvent<Payload, Context>,\n+  ...args: Hook extends \"afterRun\" ? [result: RT] : Hook extends \"onError\" ? [error: Error] : []\n+) => Promise<void> {\n+  return async (event, ...args) => {\n+    for (const middleware of middlewares) {\n+      if (middleware[methodName]) {\n+        await middleware[methodName]!(event, ...args);\n       }\n-\n-      await this.beforeRun(jobEvent);\n-\n-      let result;\n-      try {\n-        result = await def.run(jobEvent);\n-        await this.afterRun(jobEvent, result);\n-      } catch (error) {\n-        await this.onError(jobEvent, error);\n-        throw error;\n-      } finally {\n-        await this.onComplete(jobEvent);\n-      }\n-\n-      return result;\n-    },\n+    }\n+    if (fallback) {\n+      await fallback(event, ...args);\n+    }\n   };\n }\n"
                }
            ],
            "date": 1732142053689,
            "name": "Commit-0",
            "content": "export function defineJob(def) {\n  if (typeof def.run !== \"function\") {\n    throw new TypeError(\"Job must implement a `run` method!\");\n  }\n\n  const middlewares = def.middlewares || [];\n\n  // Helper to wrap lifecycle hooks and run logic\n  const wrapMiddleware = (methodName) => {\n    return async (...args) => {\n      for (const middleware of middlewares) {\n        if (typeof middleware[methodName] === \"function\") {\n          await middleware[methodName](...args);\n        }\n      }\n      if (typeof def[methodName] === \"function\") {\n        await def[methodName](...args);\n      }\n    };\n  };\n\n  return {\n    ...def,\n    async beforeRun(event) {\n      await wrapMiddleware(\"beforeRun\")(event);\n    },\n    async afterRun(event, result) {\n      await wrapMiddleware(\"afterRun\")(event, result);\n    },\n    async onError(event, error) {\n      await wrapMiddleware(\"onError\")(event, error);\n    },\n    async onComplete(event) {\n      await wrapMiddleware(\"onComplete\")(event);\n    },\n    async run(event) {\n      const jobEvent = { ...event, meta: def.meta };\n\n      // Validate payload with schema if provided\n      if (def.meta && def.meta.schema) {\n        jobEvent.payload = def.meta.schema.parse(event.payload);\n      }\n\n      let result;\n\n      // Run middleware that wraps the main logic\n      for (const middleware of middlewares) {\n        if (middleware.run) {\n          result = await middleware.run(jobEvent);\n          return result; // Stop execution if middleware overrides `run`\n        }\n      }\n\n      // Run the main job logic\n      result = await def.run(jobEvent);\n\n      // Call afterRun hooks\n      await this.afterRun(jobEvent, result);\n\n      return result;\n    },\n  };\n}\n"
        }
    ]
}